// Based on ocs2 ballbot example

#include <furuta_pendulum_ocs2/dynamics/FurutaPendulumSystemDynamics.h>

// robcogen
#include <iit/rbd/rbd.h>
#include <iit/rbd/traits/TraitSelector.h>

#include "furuta_pendulum_ocs2/generated/forward_dynamics.h"
#include "furuta_pendulum_ocs2/generated/inertia_properties.h"
#include "furuta_pendulum_ocs2/generated/inverse_dynamics.h"
#include "furuta_pendulum_ocs2/generated/jsim.h"
#include "furuta_pendulum_ocs2/generated/transforms.h"

namespace ocs2
{
namespace furuta_pendulum
{

ad_vector_t FurutaPendulumSystemDynamics::systemFlowMap(
  ad_scalar_t time, const ad_vector_t & state, const ad_vector_t & input,
  const ad_vector_t & parameters) const
{
  // test for the autogenerated code
  iit::FurutaPendulum::tpl::JointState<ad_scalar_t> qdd;
  iit::FurutaPendulum::tpl::JointState<ad_scalar_t> new_input;
  new_input(0) = input(0);
  new_input(1) = 0.0;

  using trait_t = typename iit::rbd::tpl::TraitSelector<ad_scalar_t>::Trait;
  iit::FurutaPendulum::dyn::tpl::InertiaProperties<trait_t> inertias;
  iit::FurutaPendulum::tpl::MotionTransforms<trait_t> transforms;
  iit::FurutaPendulum::dyn::tpl::ForwardDynamics<trait_t> forward_dyn(inertias, transforms);
  forward_dyn.fd(qdd, state.head<2>(), state.tail<2>(), new_input);

  // dxdt
  ad_vector_t stateDerivative(4);
  stateDerivative << state.tail<2>(), qdd;
  return stateDerivative;
}

// ad_vector_t FurutaPendulumSystemDynamics::systemFlowMap(
//   ad_scalar_t time, const ad_vector_t & state, const ad_vector_t & input,
//   const ad_vector_t & parameters) const
// {
//   scalar_t cartMass_ = 1.0;       // [kg]
//   scalar_t poleMass_ = 1.0;       // [kg]
//   scalar_t poleLength_ = 1.0;     // [m]
//   scalar_t maxInput_ = 6.0;       // [N]
//   scalar_t gravity_ = 9.8;        // [m/s^2]
//   scalar_t poleHalfLength_ = -1;  // [m]
//   scalar_t poleMoi_ = -1;         // [kg*m^2]
//   scalar_t poleSteinerMoi_ = -1;  // [kg*m^2]
  
//   poleHalfLength_ = poleLength_ / 2.0;
//   poleMoi_ = 1.0 / 12.0 * poleMass_ * (poleLength_ * poleLength_);
//   poleSteinerMoi_ = poleMoi_ + poleMass_ * (poleHalfLength_ * poleHalfLength_);

//   const ad_scalar_t cosTheta = cos(state(0));
//   const ad_scalar_t sinTheta = sin(state(0));

//   // Inertia tensor
//   Eigen::Matrix<ad_scalar_t, 2, 2> I;
//   I << static_cast<ad_scalar_t>(poleSteinerMoi_),
//     static_cast<ad_scalar_t>(poleMass_ * poleHalfLength_ * cosTheta),
//     static_cast<ad_scalar_t>(poleMass_ * poleHalfLength_ * cosTheta),
//     static_cast<ad_scalar_t>(cartMass_ + poleMass_);

//   // RHS
//   Eigen::Matrix<ad_scalar_t, 2, 1> rhs(
//     poleMass_ * poleHalfLength_ * gravity_ * sinTheta,
//     input(0) + poleMass_ * poleHalfLength_ * pow(state(2), 2) * sinTheta);

//   // dxdt
//   ad_vector_t stateDerivative(STATE_DIM);
//   stateDerivative << state.tail<2>(), I.inverse() * rhs;
//   return stateDerivative;
// }

}  // namespace furuta_pendulum
}  // namespace ocs2
